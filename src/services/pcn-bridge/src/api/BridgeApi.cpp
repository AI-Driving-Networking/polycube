/**
* bridge API
* bridge API generated from bridge.yang
*
* OpenAPI spec version: 1.0.0
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
*/


/* Do not edit this file manually */


#include "BridgeApi.h"

namespace io {
namespace swagger {
namespace server {
namespace api {

using namespace io::swagger::server::model;

BridgeApi::BridgeApi() {
    setupRoutes();
};

void BridgeApi::control_handler(const HttpHandleRequest &request, HttpHandleResponse &response) {
    try {
        auto s = router.route(request, response);
        if (s == Rest::Router::Status::NotFound) {
          response.send(Http::Code::Not_Found);
        }
    } catch (std::runtime_error &e) {
      response.send(polycube::service::Http::Code::Bad_Request, e.what());
    }
}

void BridgeApi::setupRoutes() {
    using namespace polycube::service::Rest;

    Routes::Post(router, base + "/bridge/:name/", Routes::bind(&BridgeApi::create_bridge_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/", Routes::bind(&BridgeApi::create_bridge_filteringdatabase_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/filteringdatabase/", Routes::bind(&BridgeApi::create_bridge_filteringdatabase_list_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/access/", Routes::bind(&BridgeApi::create_bridge_ports_access_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/", Routes::bind(&BridgeApi::create_bridge_ports_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/", Routes::bind(&BridgeApi::create_bridge_ports_list_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/", Routes::bind(&BridgeApi::create_bridge_ports_stp_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/stp/", Routes::bind(&BridgeApi::create_bridge_ports_stp_list_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/:vlanid/", Routes::bind(&BridgeApi::create_bridge_ports_trunk_allowed_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/", Routes::bind(&BridgeApi::create_bridge_ports_trunk_allowed_list_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/ports/:ports_name/trunk/", Routes::bind(&BridgeApi::create_bridge_ports_trunk_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/stp/:vlan/", Routes::bind(&BridgeApi::create_bridge_stp_by_id_handler, this));
    Routes::Post(router, base + "/bridge/:name/stp/", Routes::bind(&BridgeApi::create_bridge_stp_list_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/", Routes::bind(&BridgeApi::delete_bridge_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/", Routes::bind(&BridgeApi::delete_bridge_filteringdatabase_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/filteringdatabase/", Routes::bind(&BridgeApi::delete_bridge_filteringdatabase_list_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/access/", Routes::bind(&BridgeApi::delete_bridge_ports_access_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/", Routes::bind(&BridgeApi::delete_bridge_ports_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/", Routes::bind(&BridgeApi::delete_bridge_ports_list_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/", Routes::bind(&BridgeApi::delete_bridge_ports_stp_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/stp/", Routes::bind(&BridgeApi::delete_bridge_ports_stp_list_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/:vlanid/", Routes::bind(&BridgeApi::delete_bridge_ports_trunk_allowed_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/", Routes::bind(&BridgeApi::delete_bridge_ports_trunk_allowed_list_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/ports/:ports_name/trunk/", Routes::bind(&BridgeApi::delete_bridge_ports_trunk_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/stp/:vlan/", Routes::bind(&BridgeApi::delete_bridge_stp_by_id_handler, this));
    Routes::Delete(router, base + "/bridge/:name/stp/", Routes::bind(&BridgeApi::delete_bridge_stp_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/agingtime/", Routes::bind(&BridgeApi::read_bridge_agingtime_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/", Routes::bind(&BridgeApi::read_bridge_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/age/", Routes::bind(&BridgeApi::read_bridge_filteringdatabase_age_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/", Routes::bind(&BridgeApi::read_bridge_filteringdatabase_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/entrytype/", Routes::bind(&BridgeApi::read_bridge_filteringdatabase_entrytype_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/filteringdatabase/", Routes::bind(&BridgeApi::read_bridge_filteringdatabase_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/port/", Routes::bind(&BridgeApi::read_bridge_filteringdatabase_port_by_id_handler, this));
    Routes::Get(router, base + "/bridge/", Routes::bind(&BridgeApi::read_bridge_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/access/", Routes::bind(&BridgeApi::read_bridge_ports_access_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/access/vlanid/", Routes::bind(&BridgeApi::read_bridge_ports_access_vlanid_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/address/", Routes::bind(&BridgeApi::read_bridge_ports_address_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/", Routes::bind(&BridgeApi::read_bridge_ports_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/", Routes::bind(&BridgeApi::read_bridge_ports_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/mode/", Routes::bind(&BridgeApi::read_bridge_ports_mode_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/peer/", Routes::bind(&BridgeApi::read_bridge_ports_peer_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/status/", Routes::bind(&BridgeApi::read_bridge_ports_status_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/", Routes::bind(&BridgeApi::read_bridge_ports_stp_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/stp/", Routes::bind(&BridgeApi::read_bridge_ports_stp_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/pathcost/", Routes::bind(&BridgeApi::read_bridge_ports_stp_pathcost_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/portpriority/", Routes::bind(&BridgeApi::read_bridge_ports_stp_portpriority_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/state/", Routes::bind(&BridgeApi::read_bridge_ports_stp_state_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/:vlanid/", Routes::bind(&BridgeApi::read_bridge_ports_trunk_allowed_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/", Routes::bind(&BridgeApi::read_bridge_ports_trunk_allowed_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/trunk/", Routes::bind(&BridgeApi::read_bridge_ports_trunk_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/trunk/nativevlan/", Routes::bind(&BridgeApi::read_bridge_ports_trunk_nativevlan_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/ports/:ports_name/uuid/", Routes::bind(&BridgeApi::read_bridge_ports_uuid_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/address/", Routes::bind(&BridgeApi::read_bridge_stp_address_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/", Routes::bind(&BridgeApi::read_bridge_stp_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/forwarddelay/", Routes::bind(&BridgeApi::read_bridge_stp_forwarddelay_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/hellotime/", Routes::bind(&BridgeApi::read_bridge_stp_hellotime_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/", Routes::bind(&BridgeApi::read_bridge_stp_list_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/maxmessageage/", Routes::bind(&BridgeApi::read_bridge_stp_maxmessageage_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stp/:vlan/priority/", Routes::bind(&BridgeApi::read_bridge_stp_priority_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/stpenabled/", Routes::bind(&BridgeApi::read_bridge_stpenabled_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/uuid/", Routes::bind(&BridgeApi::read_bridge_uuid_by_id_handler, this));
    Routes::Get(router, base + "/bridge/:name/type/", Routes::bind(&BridgeApi::read_bridge_type_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/agingtime/", Routes::bind(&BridgeApi::update_bridge_agingtime_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/", Routes::bind(&BridgeApi::update_bridge_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/", Routes::bind(&BridgeApi::update_bridge_filteringdatabase_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/entrytype/", Routes::bind(&BridgeApi::update_bridge_filteringdatabase_entrytype_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/filteringdatabase/", Routes::bind(&BridgeApi::update_bridge_filteringdatabase_list_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/filteringdatabase/:vlan/:address/port/", Routes::bind(&BridgeApi::update_bridge_filteringdatabase_port_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/access/", Routes::bind(&BridgeApi::update_bridge_ports_access_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/access/vlanid/", Routes::bind(&BridgeApi::update_bridge_ports_access_vlanid_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/address/", Routes::bind(&BridgeApi::update_bridge_ports_address_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/", Routes::bind(&BridgeApi::update_bridge_ports_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/", Routes::bind(&BridgeApi::update_bridge_ports_list_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/mode/", Routes::bind(&BridgeApi::update_bridge_ports_mode_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/peer/", Routes::bind(&BridgeApi::update_bridge_ports_peer_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/status/", Routes::bind(&BridgeApi::update_bridge_ports_status_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/", Routes::bind(&BridgeApi::update_bridge_ports_stp_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/stp/", Routes::bind(&BridgeApi::update_bridge_ports_stp_list_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/pathcost/", Routes::bind(&BridgeApi::update_bridge_ports_stp_pathcost_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/stp/:vlan/portpriority/", Routes::bind(&BridgeApi::update_bridge_ports_stp_portpriority_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/:vlanid/", Routes::bind(&BridgeApi::update_bridge_ports_trunk_allowed_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/trunk/allowed/", Routes::bind(&BridgeApi::update_bridge_ports_trunk_allowed_list_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/trunk/", Routes::bind(&BridgeApi::update_bridge_ports_trunk_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/ports/:ports_name/trunk/nativevlan/", Routes::bind(&BridgeApi::update_bridge_ports_trunk_nativevlan_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/address/", Routes::bind(&BridgeApi::update_bridge_stp_address_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/", Routes::bind(&BridgeApi::update_bridge_stp_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/forwarddelay/", Routes::bind(&BridgeApi::update_bridge_stp_forwarddelay_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/hellotime/", Routes::bind(&BridgeApi::update_bridge_stp_hellotime_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/", Routes::bind(&BridgeApi::update_bridge_stp_list_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/maxmessageage/", Routes::bind(&BridgeApi::update_bridge_stp_maxmessageage_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stp/:vlan/priority/", Routes::bind(&BridgeApi::update_bridge_stp_priority_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/stpenabled/", Routes::bind(&BridgeApi::update_bridge_stpenabled_by_id_handler, this));
    Routes::Put(router, base + "/bridge/:name/type/", Routes::bind(&BridgeApi::update_bridge_type_by_id_handler, this));
}

void BridgeApi::create_bridge_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    BridgeSchema bridge;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    bridge.fromJson(request_body);
    auto x = create_bridge_by_id(name, bridge);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_filteringdatabase_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();

    // Getting the body param
    FilteringdatabaseSchema filteringdatabase;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    filteringdatabase.fromJson(request_body);
    auto x = create_bridge_filteringdatabase_by_id(name, vlan, address, filteringdatabase);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_filteringdatabase_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<FilteringdatabaseSchema> filteringdatabase;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      FilteringdatabaseSchema a;
      a.fromJson(j);
      filteringdatabase.push_back(a);
    }
    auto x = create_bridge_filteringdatabase_list_by_id(name, filteringdatabase);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_access_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsAccessSchema access;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    access.fromJson(request_body);
    auto x = create_bridge_ports_access_by_id(name, portsName, access);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsSchema ports;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    ports.fromJson(request_body);
    auto x = create_bridge_ports_by_id(name, portsName, ports);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<PortsSchema> ports;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsSchema a;
      a.fromJson(j);
      ports.push_back(a);
    }
    auto x = create_bridge_ports_list_by_id(name, ports);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    PortsStpSchema stp;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    stp.fromJson(request_body);
    auto x = create_bridge_ports_stp_by_id(name, portsName, vlan, stp);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::vector<PortsStpSchema> stp;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsStpSchema a;
      a.fromJson(j);
      stp.push_back(a);
    }
    auto x = create_bridge_ports_stp_list_by_id(name, portsName, stp);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_trunk_allowed_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlanid = request.param(":vlanid").as<std::string>();

    // Getting the body param
    PortsTrunkAllowedSchema allowed;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    allowed.fromJson(request_body);
    auto x = create_bridge_ports_trunk_allowed_by_id(name, portsName, vlanid, allowed);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_trunk_allowed_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::vector<PortsTrunkAllowedSchema> allowed;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsTrunkAllowedSchema a;
      a.fromJson(j);
      allowed.push_back(a);
    }
    auto x = create_bridge_ports_trunk_allowed_list_by_id(name, portsName, allowed);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_ports_trunk_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsTrunkSchema trunk;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    trunk.fromJson(request_body);
    auto x = create_bridge_ports_trunk_by_id(name, portsName, trunk);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    StpSchema stp;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    stp.fromJson(request_body);
    auto x = create_bridge_stp_by_id(name, vlan, stp);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::create_bridge_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<StpSchema> stp;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      StpSchema a;
      a.fromJson(j);
      stp.push_back(a);
    }
    auto x = create_bridge_stp_list_by_id(name, stp);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::delete_bridge_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();



    delete_bridge_by_id(name);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_filteringdatabase_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();



    delete_bridge_filteringdatabase_by_id(name, vlan, address);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_filteringdatabase_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    delete_bridge_filteringdatabase_list_by_id(name);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_access_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    delete_bridge_ports_access_by_id(name, portsName);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    delete_bridge_ports_by_id(name, portsName);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    delete_bridge_ports_list_by_id(name);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    delete_bridge_ports_stp_by_id(name, portsName, vlan);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    delete_bridge_ports_stp_list_by_id(name, portsName);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_trunk_allowed_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlanid = request.param(":vlanid").as<std::string>();



    delete_bridge_ports_trunk_allowed_by_id(name, portsName, vlanid);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_trunk_allowed_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    delete_bridge_ports_trunk_allowed_list_by_id(name, portsName);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_ports_trunk_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    delete_bridge_ports_trunk_by_id(name, portsName);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    delete_bridge_stp_by_id(name, vlan);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::delete_bridge_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    delete_bridge_stp_list_by_id(name);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::read_bridge_agingtime_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();



    auto x = read_bridge_agingtime_by_id(name);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_by_id_get_list();
          #else // element is complex
          val["params"] = BridgeSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = BridgeSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_by_id(name);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_filteringdatabase_age_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();



    auto x = read_bridge_filteringdatabase_age_by_id(name, vlan, address);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_filteringdatabase_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_by_id_get_list();
          #else // element is complex
          val["params"] = FilteringdatabaseSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = FilteringdatabaseSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_filteringdatabase_by_id(name, vlan, address);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_filteringdatabase_entrytype_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();



    auto x = read_bridge_filteringdatabase_entrytype_by_id(name, vlan, address);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_filteringdatabase_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_list_by_id_get_list();
          #else // element is complex
          val["params"] = FilteringdatabaseSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = FilteringdatabaseSchema::getKeys();
          val["elements"] = read_bridge_filteringdatabase_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = FilteringdatabaseSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_filteringdatabase_list_by_id(name);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_filteringdatabase_port_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();



    auto x = read_bridge_filteringdatabase_port_by_id(name, vlan, address);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_list_by_id_get_list();
          #else // element is complex
          val["params"] = BridgeSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = BridgeSchema::getKeys();
          val["elements"] = read_bridge_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = BridgeSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_list_by_id();
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_access_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsAccessSchema::getKeys();
          val["elements"] = read_bridge_ports_access_by_id_get_list();
          #else // element is complex
          val["params"] = PortsAccessSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsAccessSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsAccessSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsAccessSchema::getKeys();
          val["elements"] = read_bridge_ports_access_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsAccessSchema::getKeys();
          val["elements"] = read_bridge_ports_access_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsAccessSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_ports_access_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_access_vlanid_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_access_vlanid_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_address_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_address_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_by_id_get_list();
          #else // element is complex
          val["params"] = PortsSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_ports_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_list_by_id_get_list();
          #else // element is complex
          val["params"] = PortsSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsSchema::getKeys();
          val["elements"] = read_bridge_ports_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_ports_list_by_id(name);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_mode_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_mode_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_peer_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_peer_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_status_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_status_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_by_id_get_list();
          #else // element is complex
          val["params"] = PortsStpSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsStpSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_ports_stp_by_id(name, portsName, vlan);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_list_by_id_get_list();
          #else // element is complex
          val["params"] = PortsStpSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsStpSchema::getKeys();
          val["elements"] = read_bridge_ports_stp_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsStpSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_ports_stp_list_by_id(name, portsName);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_stp_pathcost_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_ports_stp_pathcost_by_id(name, portsName, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_stp_portpriority_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_ports_stp_portpriority_by_id(name, portsName, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_stp_state_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_ports_stp_state_by_id(name, portsName, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_trunk_allowed_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlanid = request.param(":vlanid").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_by_id_get_list();
          #else // element is complex
          val["params"] = PortsTrunkAllowedSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkAllowedSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_ports_trunk_allowed_by_id(name, portsName, vlanid);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_trunk_allowed_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_list_by_id_get_list();
          #else // element is complex
          val["params"] = PortsTrunkAllowedSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkAllowedSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_allowed_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkAllowedSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_ports_trunk_allowed_list_by_id(name, portsName);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_trunk_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_by_id_get_list();
          #else // element is complex
          val["params"] = PortsTrunkSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = PortsTrunkSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkSchema::getKeys();
          val["elements"] = read_bridge_ports_trunk_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = PortsTrunkSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_ports_trunk_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_trunk_nativevlan_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_trunk_nativevlan_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_ports_uuid_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();



    auto x = read_bridge_ports_uuid_by_id(name, portsName);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_address_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_stp_address_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();


    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_by_id_get_list();
          #else // element is complex
          val["params"] = StpSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = StpSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }

    auto x = read_bridge_stp_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x.toJson();
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_forwarddelay_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_stp_forwarddelay_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_hellotime_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_stp_hellotime_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();


    #define NODE_IS_LIST_CONTAINER
    using polycube::service::HelpType;
    nlohmann::json val = nlohmann::json::object();
    if (request.help_type() != HelpType::NO_HELP) {
      switch (request.help_type()) {
        case HelpType::SHOW:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_list_by_id_get_list();
          #else // element is complex
          val["params"] = StpSchema::getElements();
          #endif
        break;

        case HelpType::ADD:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::SET:
          #ifndef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getWritableLeafs();
          # else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::DEL:
          #ifdef NODE_IS_LIST_CONTAINER
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_list_by_id_get_list();
          #else
          response.send(polycube::service::Http::Code::Bad_Request);
          return;
          #endif
        break;

        case HelpType::NONE:
          #ifdef NODE_IS_LIST_CONTAINER
          auto cmds = {"add", "del", "show"};
          val["commands"] = cmds;
          val["params"] = StpSchema::getKeys();
          val["elements"] = read_bridge_stp_list_by_id_get_list();
          #else // complex type
          auto cmds = {"set", "show"};
          val["commands"] = cmds;
          val["params"] = StpSchema::getComplexElements();
          #endif
        break;
      }
      response.send(polycube::service::Http::Code::Ok, val.dump(4));
      return;
    }
    #undef NODE_IS_LIST_CONTAINER

    auto x = read_bridge_stp_list_by_id(name);
    nlohmann::json response_body;
    for (auto &i : x) {
      response_body += i.toJson();
    }
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_maxmessageage_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_stp_maxmessageage_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stp_priority_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();



    auto x = read_bridge_stp_priority_by_id(name, vlan);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_stpenabled_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();



    auto x = read_bridge_stpenabled_by_id(name);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_type_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();



    auto x = read_bridge_type_by_id(name);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::read_bridge_uuid_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();



    auto x = read_bridge_uuid_by_id(name);
    nlohmann::json response_body;
    response_body = x;
    response.send(polycube::service::Http::Code::Ok, response_body.dump(4));
}

void BridgeApi::update_bridge_agingtime_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    int32_t agingtime;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    agingtime = request_body;
    update_bridge_agingtime_by_id(name, agingtime);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    BridgeSchema bridge;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    bridge.fromJson(request_body);
    update_bridge_by_id(name, bridge);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_filteringdatabase_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();

    // Getting the body param
    FilteringdatabaseSchema filteringdatabase;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    filteringdatabase.fromJson(request_body);
    update_bridge_filteringdatabase_by_id(name, vlan, address, filteringdatabase);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_filteringdatabase_entrytype_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();

    // Getting the body param
    std::string entrytype;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    entrytype = request_body;
    update_bridge_filteringdatabase_entrytype_by_id(name, vlan, address, entrytype);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_filteringdatabase_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<FilteringdatabaseSchema> filteringdatabase;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      FilteringdatabaseSchema a;
      a.fromJson(j);
      filteringdatabase.push_back(a);
    }
    update_bridge_filteringdatabase_list_by_id(name, filteringdatabase);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_filteringdatabase_port_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();
    auto address = request.param(":address").as<std::string>();

    // Getting the body param
    std::string port;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    port = request_body;
    update_bridge_filteringdatabase_port_by_id(name, vlan, address, port);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_access_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsAccessSchema access;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    access.fromJson(request_body);
    update_bridge_ports_access_by_id(name, portsName, access);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_access_vlanid_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    int32_t vlanid;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    vlanid = request_body;
    update_bridge_ports_access_vlanid_by_id(name, portsName, vlanid);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_address_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::string address;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    address = request_body;
    update_bridge_ports_address_by_id(name, portsName, address);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsSchema ports;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    ports.fromJson(request_body);
    update_bridge_ports_by_id(name, portsName, ports);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<PortsSchema> ports;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsSchema a;
      a.fromJson(j);
      ports.push_back(a);
    }
    update_bridge_ports_list_by_id(name, ports);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_mode_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::string mode;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    mode = request_body;
    update_bridge_ports_mode_by_id(name, portsName, mode);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_peer_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::string peer;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    peer = request_body;
    update_bridge_ports_peer_by_id(name, portsName, peer);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_status_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::string status;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    status = request_body;
    update_bridge_ports_status_by_id(name, portsName, status);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    PortsStpSchema stp;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    stp.fromJson(request_body);
    update_bridge_ports_stp_by_id(name, portsName, vlan, stp);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::vector<PortsStpSchema> stp;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsStpSchema a;
      a.fromJson(j);
      stp.push_back(a);
    }
    update_bridge_ports_stp_list_by_id(name, portsName, stp);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_stp_pathcost_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t pathcost;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    pathcost = request_body;
    update_bridge_ports_stp_pathcost_by_id(name, portsName, vlan, pathcost);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_stp_portpriority_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t portpriority;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    portpriority = request_body;
    update_bridge_ports_stp_portpriority_by_id(name, portsName, vlan, portpriority);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_trunk_allowed_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();
    auto vlanid = request.param(":vlanid").as<std::string>();

    // Getting the body param
    PortsTrunkAllowedSchema allowed;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    allowed.fromJson(request_body);
    update_bridge_ports_trunk_allowed_by_id(name, portsName, vlanid, allowed);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_trunk_allowed_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    std::vector<PortsTrunkAllowedSchema> allowed;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      PortsTrunkAllowedSchema a;
      a.fromJson(j);
      allowed.push_back(a);
    }
    update_bridge_ports_trunk_allowed_list_by_id(name, portsName, allowed);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_trunk_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    PortsTrunkSchema trunk;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    trunk.fromJson(request_body);
    update_bridge_ports_trunk_by_id(name, portsName, trunk);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_ports_trunk_nativevlan_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto portsName = request.param(":ports_name").as<std::string>();

    // Getting the body param
    int32_t nativevlan;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    nativevlan = request_body;
    update_bridge_ports_trunk_nativevlan_by_id(name, portsName, nativevlan);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_address_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    std::string address;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    address = request_body;
    update_bridge_stp_address_by_id(name, vlan, address);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    StpSchema stp;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    stp.fromJson(request_body);
    update_bridge_stp_by_id(name, vlan, stp);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_forwarddelay_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t forwarddelay;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    forwarddelay = request_body;
    update_bridge_stp_forwarddelay_by_id(name, vlan, forwarddelay);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_hellotime_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t hellotime;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    hellotime = request_body;
    update_bridge_stp_hellotime_by_id(name, vlan, hellotime);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_list_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::vector<StpSchema> stp;

    #define NODE_IS_LIST_CONTAINER
    #undef NODE_IS_LIST_CONTAINER

    nlohmann::json request_body = nlohmann::json::parse(request.body());
    for (auto &j : request_body) {
      StpSchema a;
      a.fromJson(j);
      stp.push_back(a);
    }
    update_bridge_stp_list_by_id(name, stp);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_maxmessageage_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t maxmessageage;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    maxmessageage = request_body;
    update_bridge_stp_maxmessageage_by_id(name, vlan, maxmessageage);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stp_priority_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();
    auto vlan = request.param(":vlan").as<std::string>();

    // Getting the body param
    int32_t priority;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    priority = request_body;
    update_bridge_stp_priority_by_id(name, vlan, priority);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_stpenabled_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    bool stpenabled;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    stpenabled = request_body;
    update_bridge_stpenabled_by_id(name, stpenabled);
    response.send(polycube::service::Http::Code::Ok);
}

void BridgeApi::update_bridge_type_by_id_handler(const polycube::service::Rest::Request &request, polycube::service::HttpHandleResponse &response) {
    // Getting the path params
    auto name = request.param(":name").as<std::string>();

    // Getting the body param
    std::string type;


    nlohmann::json request_body = nlohmann::json::parse(request.body());
    // The conversion is done automatically by the json library
    type = request_body;
    update_bridge_type_by_id(name, type);
    response.send(polycube::service::Http::Code::Ok);
}


}
}
}
}

